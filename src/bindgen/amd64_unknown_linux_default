/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair {
    pub _address: u8,
}
pub type pair_first_type = u8;
pub type pair_second_type = u8;
pub type pair__PCCP = u8;
pub type pair__PCCFP = u8;
pub type micro = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duration {
    pub _address: u8,
}
pub type duration___is_float = u8;
pub type duration___is_harmonic = u8;
pub type duration_rep = u8;
pub type duration_period = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_point {
    pub _address: u8,
}
pub type time_point_clock = u8;
pub type time_point_duration = u8;
pub type time_point_rep = u8;
pub type time_point_period = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct system_clock {
    pub _bindgen_opaque_blob: u8,
}
pub type system_clock_duration = u64;
pub type system_clock_rep = u64;
pub type system_clock_period = u8;
pub type system_clock_time_point = u64;
#[test]
fn bindgen_test_layout_system_clock() {
    assert_eq!(
        ::std::mem::size_of::<system_clock>(),
        1usize,
        concat!("Size of: ", stringify!(system_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<system_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(system_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn system_clock_now() -> system_clock_time_point;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock9to_time_tERKNS_10time_pointIS1_NS_8durationIlSt5ratioILl1ELl1000000000EEEEEE"]
    pub fn system_clock_to_time_t(__t: *const system_clock_time_point) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock11from_time_tEl"]
    pub fn system_clock_from_time_t(__t: time_t) -> system_clock_time_point;
}
impl system_clock {
    #[inline]
    pub unsafe fn now() -> system_clock_time_point {
        system_clock_now()
    }
    #[inline]
    pub unsafe fn to_time_t(__t: *const system_clock_time_point) -> time_t {
        system_clock_to_time_t(__t)
    }
    #[inline]
    pub unsafe fn from_time_t(__t: time_t) -> system_clock_time_point {
        system_clock_from_time_t(__t)
    }
}
pub const system_clock_is_steady: bool = false;
pub type string = [u64; 4usize];
pub type atomic_bool = u8;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
#[repr(C)]
pub struct Clock__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Clock {
    pub vtable_: *const Clock__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_Clock() {
    assert_eq!(
        ::std::mem::size_of::<Clock>(),
        8usize,
        concat!("Size of: ", stringify!(Clock))
    );
    assert_eq!(
        ::std::mem::align_of::<Clock>(),
        8usize,
        concat!("Alignment of ", stringify!(Clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex5Clock8getPhaseERS0_"]
    pub fn Clock_getPhase(this: *mut ::std::os::raw::c_void, c: *mut Clock) -> dur;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex5ClockD1Ev"]
    pub fn Clock_Clock_destructor(this: *mut Clock);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex5Clock3dieEv"]
    pub fn Clock_die(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct VariableFrequencyClock {
    pub _base: Clock,
    pub clockSrc_: *mut Clock,
    pub frequencySrc_: f64,
    pub frequency_: f64,
    pub markerSrc_: tp,
    pub marker_: tp,
    pub rolledOver_: bool,
}
#[test]
fn bindgen_test_layout_VariableFrequencyClock() {
    assert_eq!(
        ::std::mem::size_of::<VariableFrequencyClock>(),
        56usize,
        concat!("Size of: ", stringify!(VariableFrequencyClock))
    );
    assert_eq!(
        ::std::mem::align_of::<VariableFrequencyClock>(),
        8usize,
        concat!("Alignment of ", stringify!(VariableFrequencyClock))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VariableFrequencyClock>())).clockSrc_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(clockSrc_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VariableFrequencyClock>())).frequencySrc_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(frequencySrc_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VariableFrequencyClock>())).frequency_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(frequency_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VariableFrequencyClock>())).markerSrc_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(markerSrc_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableFrequencyClock>())).marker_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(marker_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VariableFrequencyClock>())).rolledOver_ as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableFrequencyClock),
            "::",
            stringify!(rolledOver_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex22VariableFrequencyClock8setValueENSt6chrono10time_pointINS1_3_V212system_clockENS1_8durationIlSt5ratioILl1ELl1000000EEEEEE"]
    pub fn VariableFrequencyClock_setValue(this: *mut VariableFrequencyClock, arg1: tp);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3dex22VariableFrequencyClock12getFrequencyEv"]
    pub fn VariableFrequencyClock_getFrequency(this: *const VariableFrequencyClock) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex22VariableFrequencyClock12setFrequencyEd"]
    pub fn VariableFrequencyClock_setFrequency(this: *mut VariableFrequencyClock, arg1: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex22VariableFrequencyClockC1ERNS_5ClockE"]
    pub fn VariableFrequencyClock_VariableFrequencyClock(
        this: *mut VariableFrequencyClock,
        arg1: *mut Clock,
    );
}
impl VariableFrequencyClock {
    #[inline]
    pub unsafe fn setValue(&mut self, arg1: tp) {
        VariableFrequencyClock_setValue(self, arg1)
    }
    #[inline]
    pub unsafe fn getFrequency(&self) -> f64 {
        VariableFrequencyClock_getFrequency(self)
    }
    #[inline]
    pub unsafe fn setFrequency(&mut self, arg1: f64) {
        VariableFrequencyClock_setFrequency(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Clock) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        VariableFrequencyClock_VariableFrequencyClock(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex22VariableFrequencyClock8getValueEv"]
    pub fn VariableFrequencyClock_getValue(this: *mut ::std::os::raw::c_void) -> tp;
}
#[repr(C)]
pub struct PhaseLockedClock {
    pub _base: Clock,
    pub primaryClock_: *mut Clock,
    pub referenceClock_: *mut Clock,
    pub variableFrequencyClock_: VariableFrequencyClock,
    pub inSync_: bool,
    pub phase_: dur,
    pub phasePrev_: dur,
    pub variableValue_: tp,
    pub variableValuePrev_: tp,
    pub primaryValue_: tp,
    pub primaryValuePrev_: tp,
    pub primaryFrequencyAvg_: f64,
    pub phasePanic_: dur,
    pub updatePanic_: dur,
    pub updatePrev_: tp,
}
#[test]
fn bindgen_test_layout_PhaseLockedClock() {
    assert_eq!(
        ::std::mem::size_of::<PhaseLockedClock>(),
        168usize,
        concat!("Size of: ", stringify!(PhaseLockedClock))
    );
    assert_eq!(
        ::std::mem::align_of::<PhaseLockedClock>(),
        8usize,
        concat!("Alignment of ", stringify!(PhaseLockedClock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).primaryClock_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(primaryClock_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhaseLockedClock>())).referenceClock_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(referenceClock_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhaseLockedClock>())).variableFrequencyClock_ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(variableFrequencyClock_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).inSync_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(inSync_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).phase_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(phase_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).phasePrev_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(phasePrev_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).variableValue_ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(variableValue_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhaseLockedClock>())).variableValuePrev_ as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(variableValuePrev_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).primaryValue_ as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(primaryValue_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhaseLockedClock>())).primaryValuePrev_ as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(primaryValuePrev_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhaseLockedClock>())).primaryFrequencyAvg_ as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(primaryFrequencyAvg_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).phasePanic_ as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(phasePanic_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).updatePanic_ as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(updatePanic_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhaseLockedClock>())).updatePrev_ as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PhaseLockedClock),
            "::",
            stringify!(updatePrev_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3dex16PhaseLockedClock14isSynchronizedEv"]
    pub fn PhaseLockedClock_isSynchronized(this: *const PhaseLockedClock) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock9getOffsetEv"]
    pub fn PhaseLockedClock_getOffset(this: *mut PhaseLockedClock) -> dur;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock13setPhasePanicENSt6chrono8durationIlSt5ratioILl1ELl1000000EEEE"]
    pub fn PhaseLockedClock_setPhasePanic(this: *mut PhaseLockedClock, phasePanic: dur);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock14setUpdatePanicENSt6chrono8durationIlSt5ratioILl1ELl1000000EEEE"]
    pub fn PhaseLockedClock_setUpdatePanic(this: *mut PhaseLockedClock, usec: dur);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock3runERSt6atomicIbE"]
    pub fn PhaseLockedClock_run(this: *mut PhaseLockedClock, arg1: *mut atomic_bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock6updateEv"]
    pub fn PhaseLockedClock_update(this: *mut PhaseLockedClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock11updatePhaseEv"]
    pub fn PhaseLockedClock_updatePhase(this: *mut PhaseLockedClock) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock11updateClockEv"]
    pub fn PhaseLockedClock_updateClock(this: *mut PhaseLockedClock) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock8setClockEv"]
    pub fn PhaseLockedClock_setClock(this: *mut PhaseLockedClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClockC1ERNS_5ClockES2_"]
    pub fn PhaseLockedClock_PhaseLockedClock(
        this: *mut PhaseLockedClock,
        primary: *mut Clock,
        reference: *mut Clock,
    );
}
impl PhaseLockedClock {
    #[inline]
    pub unsafe fn isSynchronized(&self) -> bool {
        PhaseLockedClock_isSynchronized(self)
    }
    #[inline]
    pub unsafe fn getOffset(&mut self) -> dur {
        PhaseLockedClock_getOffset(self)
    }
    #[inline]
    pub unsafe fn setPhasePanic(&mut self, phasePanic: dur) {
        PhaseLockedClock_setPhasePanic(self, phasePanic)
    }
    #[inline]
    pub unsafe fn setUpdatePanic(&mut self, usec: dur) {
        PhaseLockedClock_setUpdatePanic(self, usec)
    }
    #[inline]
    pub unsafe fn run(&mut self, arg1: *mut atomic_bool) {
        PhaseLockedClock_run(self, arg1)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        PhaseLockedClock_update(self)
    }
    #[inline]
    pub unsafe fn updatePhase(&mut self) -> bool {
        PhaseLockedClock_updatePhase(self)
    }
    #[inline]
    pub unsafe fn updateClock(&mut self) -> bool {
        PhaseLockedClock_updateClock(self)
    }
    #[inline]
    pub unsafe fn setClock(&mut self) {
        PhaseLockedClock_setClock(self)
    }
    #[inline]
    pub unsafe fn new(primary: *mut Clock, reference: *mut Clock) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PhaseLockedClock_PhaseLockedClock(__bindgen_tmp.as_mut_ptr(), primary, reference);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClockD1Ev"]
    pub fn PhaseLockedClock_PhaseLockedClock_destructor(this: *mut PhaseLockedClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock3dieEv"]
    pub fn PhaseLockedClock_die(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex16PhaseLockedClock8getValueEv"]
    pub fn PhaseLockedClock_getValue(this: *mut ::std::os::raw::c_void) -> tp;
}
#[doc = " A clock that gets its time over the network from a ClockServer."]
#[doc = ""]
#[doc = " To get the time, the clock sends a timestamped packet to to the server."]
#[doc = " The server responds with its current time.  The client then timestamps"]
#[doc = " the response.  The client can then calculate an estimated offset between"]
#[doc = " the two clocks as well as an error bound on this calculation."]
#[doc = ""]
#[doc = " Because of this, getPhase() should really be used on a ClockClient."]
#[doc = " However, getValue() can be used.  getValue() calculates the current time"]
#[doc = " by using the HighFrequencyClock as a timekeeper."]
#[repr(C)]
#[repr(align(8))]
pub struct ClockClient {
    pub _bindgen_opaque_blob: [u64; 35usize],
}
#[test]
fn bindgen_test_layout_ClockClient() {
    assert_eq!(
        ::std::mem::size_of::<ClockClient>(),
        280usize,
        concat!("Size of: ", stringify!(ClockClient))
    );
    assert_eq!(
        ::std::mem::align_of::<ClockClient>(),
        8usize,
        concat!("Alignment of ", stringify!(ClockClient))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3dex11ClockClient10getTimeoutEv"]
    pub fn ClockClient_getTimeout(this: *const ClockClient) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClient10setTimeoutEl"]
    pub fn ClockClient_setTimeout(this: *mut ClockClient, usec: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3dex11ClockClient3rttEv"]
    pub fn ClockClient_rtt(this: *const ClockClient) -> dur;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClient14setAcknowledgeEb"]
    pub fn ClockClient_setAcknowledge(this: *mut ClockClient, acknowledge: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClientC1EN7kissnet8endpointE"]
    pub fn ClockClient_ClockClient(this: *mut ClockClient, arg1: endpoint);
}
impl ClockClient {
    #[inline]
    pub unsafe fn getTimeout(&self) -> ::std::os::raw::c_int {
        ClockClient_getTimeout(self)
    }
    #[inline]
    pub unsafe fn setTimeout(&mut self, usec: i64) {
        ClockClient_setTimeout(self, usec)
    }
    #[inline]
    pub unsafe fn rtt(&self) -> dur {
        ClockClient_rtt(self)
    }
    #[inline]
    pub unsafe fn setAcknowledge(&mut self, acknowledge: bool) {
        ClockClient_setAcknowledge(self, acknowledge)
    }
    #[inline]
    pub unsafe fn new(arg1: endpoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ClockClient_ClockClient(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClientD1Ev"]
    pub fn ClockClient_ClockClient_destructor(this: *mut ClockClient);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClient8getValueEv"]
    pub fn ClockClient_getValue(this: *mut ::std::os::raw::c_void) -> tp;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClient8getPhaseERNS_5ClockE"]
    pub fn ClockClient_getPhase(this: *mut ::std::os::raw::c_void, clock: *mut Clock) -> dur;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex11ClockClient3dieEv"]
    pub fn ClockClient_die(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct ConfigReader {
    pub server: *const ::std::os::raw::c_char,
    pub port: ::std::os::raw::c_uint,
    pub timeout: ::std::os::raw::c_uint,
    pub phasePanic: ::std::os::raw::c_uint,
    pub updatePanic: ::std::os::raw::c_uint,
}
pub const ConfigReader_defaultPort: ::std::os::raw::c_uint = 4444;
pub const ConfigReader_defaultTimeout: ::std::os::raw::c_uint = 1000;
pub const ConfigReader_defaultPhasePanic: ::std::os::raw::c_uint = 5000;
pub const ConfigReader_defaultUpdatePanic: ::std::os::raw::c_uint = 5000000;
#[test]
fn bindgen_test_layout_ConfigReader() {
    assert_eq!(
        ::std::mem::size_of::<ConfigReader>(),
        24usize,
        concat!("Size of: ", stringify!(ConfigReader))
    );
    assert_eq!(
        ::std::mem::align_of::<ConfigReader>(),
        8usize,
        concat!("Alignment of ", stringify!(ConfigReader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConfigReader>())).server as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigReader),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConfigReader>())).port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigReader),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConfigReader>())).timeout as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigReader),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConfigReader>())).phasePanic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigReader),
            "::",
            stringify!(phasePanic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConfigReader>())).updatePanic as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigReader),
            "::",
            stringify!(updatePanic)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReader5printEv"]
    pub fn ConfigReader_print(this: *mut ConfigReader);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReader8readFromEPKc"]
    pub fn ConfigReader_readFrom(
        this: *mut ConfigReader,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReader10buildClockEv"]
    pub fn ConfigReader_buildClock(this: *mut ConfigReader) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReader8buildPLCEv"]
    pub fn ConfigReader_buildPLC(this: *mut ConfigReader) -> *mut PhaseLockedClock;
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReaderC1Ev"]
    pub fn ConfigReader_ConfigReader(this: *mut ConfigReader);
}
extern "C" {
    #[link_name = "\u{1}_ZN3dex12ConfigReaderD1Ev"]
    pub fn ConfigReader_ConfigReader_destructor(this: *mut ConfigReader);
}
impl ConfigReader {
    #[inline]
    pub unsafe fn print(&mut self) {
        ConfigReader_print(self)
    }
    #[inline]
    pub unsafe fn readFrom(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        ConfigReader_readFrom(self, arg1)
    }
    #[inline]
    pub unsafe fn buildClock(&mut self) -> u8 {
        ConfigReader_buildClock(self)
    }
    #[inline]
    pub unsafe fn buildPLC(&mut self) -> *mut PhaseLockedClock {
        ConfigReader_buildPLC(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ConfigReader_ConfigReader(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ConfigReader_ConfigReader_destructor(self)
    }
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub type SOCKADDR = sockaddr;
#[doc = "port_t is the port"]
pub type port_t = u16;
#[doc = "An endpoint is where the network will connect to (address and port)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct endpoint {
    #[doc = "The address to connect to"]
    pub address: string,
    #[doc = "The port to connect to"]
    pub port: port_t,
}
#[test]
fn bindgen_test_layout_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<endpoint>(),
        40usize,
        concat!("Size of: ", stringify!(endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint>())).port as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint),
            "::",
            stringify!(port)
        )
    );
}
